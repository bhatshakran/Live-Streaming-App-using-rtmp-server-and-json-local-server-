{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nvar util = require('util');\n\nvar assert = require('assert');\n\nvar Stream = require('stream');\n\nvar Duplex = require('./_stream_duplex');\n\nutil.inherits(Writable, Stream);\n\nfunction WritableState(options, stream) {\n  options = options || {}; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  var hwm = options.highWaterMark;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024; // the point that it has to get to before we call _write(chunk,cb)\n  // default to pushing everything out as fast as possible.\n\n  this.lowWaterMark = options.lowWaterMark || 0; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode; // cast to ints.\n\n  this.lowWaterMark = ~~this.lowWaterMark;\n  this.highWaterMark = ~~this.highWaterMark;\n  if (this.lowWaterMark > this.highWaterMark) throw new Error('lowWaterMark cannot be higher than highWaterMark');\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' has emitted\n\n  this.finished = false; // when 'finish' is being emitted\n\n  this.finishing = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.\n\n  this.sync = false; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.buffer = [];\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n  this._writableState = new WritableState(options, this); // legacy.\n\n  this.writable = true;\n  Stream.call(this);\n} // Override this method or _write(chunk, cb)\n\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (state.ended) {\n    var er = new Error('write after end');\n    if (typeof cb === 'function') cb(er);\n    this.emit('error', er);\n    return;\n  } // Writing something other than a string or buffer will switch\n  // the stream into objectMode.\n\n\n  if (!state.objectMode && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !Buffer.isBuffer(chunk)) state.objectMode = true;\n  var len;\n  if (state.objectMode) len = 1;else {\n    len = chunk.length;\n    if (false === state.decodeStrings) chunk = [chunk, encoding || 'utf8'];else if (typeof chunk === 'string') {\n      chunk = new Buffer(chunk, encoding);\n      len = chunk.length;\n    }\n  }\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  if (ret === false) state.needDrain = true; // if we're already writing something, then just put this\n  // in the queue, and wait our turn.\n\n  if (state.writing) {\n    state.buffer.push([chunk, cb]);\n    return ret;\n  }\n\n  state.writing = true;\n  state.sync = true;\n  state.writelen = len;\n  state.writecb = cb;\n\n  this._write(chunk, state.onwrite);\n\n  state.sync = false;\n  return ret;\n};\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  var len = state.writelen;\n  state.writing = false;\n  state.writelen = null;\n  state.writecb = null;\n\n  if (er) {\n    if (cb) {\n      // If _write(chunk,cb) calls cb() in this tick, we still defer\n      // the *user's* write callback to the next tick.\n      // Never present an external API that is *sometimes* async!\n      if (sync) process.nextTick(function () {\n        cb(er);\n      });else cb(er);\n    } // backwards compatibility.  still emit if there was a cb.\n\n\n    stream.emit('error', er);\n    return;\n  }\n\n  state.length -= len;\n\n  if (cb) {\n    // Don't call the cb until the next tick if we're in sync mode.\n    if (sync) process.nextTick(cb);else cb();\n  }\n\n  if (state.length === 0 && (state.ended || state.ending) && !state.finished && !state.finishing) {\n    // emit 'finish' at the very end.\n    state.finishing = true;\n    stream.emit('finish');\n    state.finished = true;\n    return;\n  }\n\n  if (state.length <= state.lowWaterMark && state.needDrain) {\n    // Must force callback to be called on nextTick, so that we don't\n    // emit 'drain' before the write() consumer gets the 'false' return\n    // value, and has a chance to attach a 'drain' listener.\n    process.nextTick(function () {\n      if (!state.needDrain) return;\n      state.needDrain = false;\n      stream.emit('drain');\n    });\n  } // if there's something in the buffer waiting, then process it\n  // It would be nice if there were TCO in JS, and we could just\n  // shift the top off the buffer and _write that, but that approach\n  // causes RangeErrors when you have a very large number of very\n  // small writes, and is not very efficient otherwise.\n\n\n  if (!state.bufferProcessing && state.buffer.length) {\n    state.bufferProcessing = true;\n\n    for (var c = 0; c < state.buffer.length; c++) {\n      var chunkCb = state.buffer[c];\n      var chunk = chunkCb[0];\n      cb = chunkCb[1];\n      if (state.objectMode) len = 1;else if (false === state.decodeStrings) len = chunk[0].length;else len = chunk.length;\n      state.writelen = len;\n      state.writecb = cb;\n      state.writechunk = chunk;\n      state.writing = true;\n      state.sync = true;\n\n      stream._write(chunk, state.onwrite);\n\n      state.sync = false; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    state.bufferProcessing = false;\n    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;\n  }\n}\n\nWritable.prototype._write = function (chunk, cb) {\n  process.nextTick(function () {\n    cb(new Error('not implemented'));\n  });\n};\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState; // ignore unnecessary end() calls.\n\n  if (state.ending || state.ended || state.finished) return;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  state.ending = true;\n  if (chunk) this.write(chunk, encoding, cb);else if (state.length === 0 && !state.finishing && !state.finished) {\n    state.finishing = true;\n    this.emit('finish');\n    state.finished = true;\n    if (cb) process.nextTick(cb);\n  } else if (cb) {\n    this.once('finish', cb);\n  }\n  state.ended = true;\n};","map":{"version":3,"sources":["/Users/user/Desktop/React Apps/twitchClone/client/node_modules/flv/node_modules/readable-stream/lib/_stream_writable.js"],"names":["module","exports","Writable","WritableState","util","require","assert","Stream","Duplex","inherits","options","stream","hwm","highWaterMark","lowWaterMark","objectMode","Error","needDrain","ending","ended","finished","finishing","noDecode","decodeStrings","length","writing","sync","bufferProcessing","onwrite","er","writecb","writelen","buffer","_writableState","writable","call","prototype","write","chunk","encoding","cb","state","emit","undefined","Buffer","isBuffer","len","ret","push","_write","process","nextTick","c","chunkCb","writechunk","slice","end","once"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nvar util = require('util');\nvar assert = require('assert');\nvar Stream = require('stream');\nvar Duplex = require('./_stream_duplex');\n\nutil.inherits(Writable, Stream);\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // the point that it has to get to before we call _write(chunk,cb)\n  // default to pushing everything out as fast as possible.\n  this.lowWaterMark = options.lowWaterMark || 0;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.lowWaterMark = ~~this.lowWaterMark;\n  this.highWaterMark = ~~this.highWaterMark;\n\n  if (this.lowWaterMark > this.highWaterMark)\n    throw new Error('lowWaterMark cannot be higher than highWaterMark');\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' has emitted\n  this.finished = false;\n  // when 'finish' is being emitted\n  this.finishing = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.\n  this.sync = false;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Override this method or _write(chunk, cb)\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (state.ended) {\n    var er = new Error('write after end');\n    if (typeof cb === 'function')\n      cb(er);\n    this.emit('error', er);\n    return;\n  }\n\n  // Writing something other than a string or buffer will switch\n  // the stream into objectMode.\n  if (!state.objectMode &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !Buffer.isBuffer(chunk))\n    state.objectMode = true;\n\n  var len;\n  if (state.objectMode)\n    len = 1;\n  else {\n    len = chunk.length;\n    if (false === state.decodeStrings)\n      chunk = [chunk, encoding || 'utf8'];\n    else if (typeof chunk === 'string') {\n      chunk = new Buffer(chunk, encoding);\n      len = chunk.length;\n    }\n  }\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  if (ret === false)\n    state.needDrain = true;\n\n  // if we're already writing something, then just put this\n  // in the queue, and wait our turn.\n  if (state.writing) {\n    state.buffer.push([chunk, cb]);\n    return ret;\n  }\n\n  state.writing = true;\n  state.sync = true;\n  state.writelen = len;\n  state.writecb = cb;\n  this._write(chunk, state.onwrite);\n  state.sync = false;\n\n  return ret;\n};\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  var len = state.writelen;\n\n  state.writing = false;\n  state.writelen = null;\n  state.writecb = null;\n\n  if (er) {\n    if (cb) {\n      // If _write(chunk,cb) calls cb() in this tick, we still defer\n      // the *user's* write callback to the next tick.\n      // Never present an external API that is *sometimes* async!\n      if (sync)\n        process.nextTick(function() {\n          cb(er);\n        });\n      else\n        cb(er);\n    }\n\n    // backwards compatibility.  still emit if there was a cb.\n    stream.emit('error', er);\n    return;\n  }\n  state.length -= len;\n\n  if (cb) {\n    // Don't call the cb until the next tick if we're in sync mode.\n    if (sync)\n      process.nextTick(cb);\n    else\n      cb();\n  }\n\n  if (state.length === 0 && (state.ended || state.ending) &&\n      !state.finished && !state.finishing) {\n    // emit 'finish' at the very end.\n    state.finishing = true;\n    stream.emit('finish');\n    state.finished = true;\n    return;\n  }\n\n  if (state.length <= state.lowWaterMark && state.needDrain) {\n    // Must force callback to be called on nextTick, so that we don't\n    // emit 'drain' before the write() consumer gets the 'false' return\n    // value, and has a chance to attach a 'drain' listener.\n    process.nextTick(function() {\n      if (!state.needDrain)\n        return;\n      state.needDrain = false;\n      stream.emit('drain');\n    });\n  }\n\n  // if there's something in the buffer waiting, then process it\n  // It would be nice if there were TCO in JS, and we could just\n  // shift the top off the buffer and _write that, but that approach\n  // causes RangeErrors when you have a very large number of very\n  // small writes, and is not very efficient otherwise.\n  if (!state.bufferProcessing && state.buffer.length) {\n    state.bufferProcessing = true;\n\n    for (var c = 0; c < state.buffer.length; c++) {\n      var chunkCb = state.buffer[c];\n      var chunk = chunkCb[0];\n      cb = chunkCb[1];\n\n      if (state.objectMode)\n        len = 1;\n      else if (false === state.decodeStrings)\n        len = chunk[0].length;\n      else\n        len = chunk.length;\n\n      state.writelen = len;\n      state.writecb = cb;\n      state.writechunk = chunk;\n      state.writing = true;\n      state.sync = true;\n      stream._write(chunk, state.onwrite);\n      state.sync = false;\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    state.bufferProcessing = false;\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n}\n\nWritable.prototype._write = function(chunk, cb) {\n  process.nextTick(function() {\n    cb(new Error('not implemented'));\n  });\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  // ignore unnecessary end() calls.\n  if (state.ending || state.ended || state.finished)\n    return;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  state.ending = true;\n  if (chunk)\n    this.write(chunk, encoding, cb);\n  else if (state.length === 0 && !state.finishing && !state.finished) {\n    state.finishing = true;\n    this.emit('finish');\n    state.finished = true;\n    if (cb) process.nextTick(cb);\n  } else if (cb) {\n    this.once('finish', cb);\n  }\n\n  state.ended = true;\n};\n"]},"metadata":{},"sourceType":"script"}