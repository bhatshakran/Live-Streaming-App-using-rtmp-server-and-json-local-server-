{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar assert = require('assert');\n\nvar inherits = require('util').inherits;\n\nvar Readable = require('stream').Readable;\n\nvar debug = require('debug')('flv:decoder-stream'); // node v0.8.x compat\n\n\nif (!Readable) Readable = require('readable-stream/readable');\n/**\n * Module exports.\n */\n\nmodule.exports = DecoderStream;\n/**\n * The `DecoderStream`.\n *\n * @param {Object} opts optional options object\n * @api public\n */\n\nfunction DecoderStream(opts) {\n  if (!(this instanceof DecoderStream)) return new DecoderStream(opts);\n  Readable.call(this, opts);\n  this._chunks = [];\n}\n\ninherits(DecoderStream, Readable);\n/**\n * Readable `_read()` callback function.\n *\n * @param {Number} n number of bytes requested (ignored)\n * @param {Function} done callback function (XXX: remove...)\n * @api private\n */\n\nDecoderStream.prototype._read = function (n, done) {\n  if (this._chunks.length > 0) {\n    output.call(this);\n  } else {\n    debug('waiting for a \"_chunk\" event');\n    this.once('_chunk', output);\n  }\n\n  function output() {\n    debug('output()');\n\n    var next = this._chunks.shift();\n\n    var buf = next[0];\n    var fn = next[1];\n    fn();\n    if (this.push) this.push(buf);else done(null, buf); // XXX: old Readable stream API... remove at some point..\n  }\n};\n/**\n * Pushes a Buffer to be read from this `DecoderStream` instance. The `fn`\n * callback function only gets invoked once the ._read() function pulls the buffer\n * out to send to the user.\n *\n * @param {Buffer} buf Buffer instance\n * @param {Function} fn callback function\n * @api private\n */\n\n\nDecoderStream.prototype._pushAndWait = function (buf, fn) {\n  this._chunks.push([buf, fn]);\n\n  this.emit('_chunk');\n};","map":{"version":3,"sources":["/Users/user/Desktop/React Apps/twitchClone/client/node_modules/flv/lib/decoder-stream.js"],"names":["assert","require","inherits","Readable","debug","module","exports","DecoderStream","opts","call","_chunks","prototype","_read","n","done","length","output","once","next","shift","buf","fn","push","_pushAndWait","emit"],"mappings":"AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBC,QAA/B;;AACA,IAAIC,QAAQ,GAAGF,OAAO,CAAC,QAAD,CAAP,CAAkBE,QAAjC;;AACA,IAAIC,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,oBAAjB,CAAZ,C,CAEA;;;AACA,IAAI,CAACE,QAAL,EAAeA,QAAQ,GAAGF,OAAO,CAAC,0BAAD,CAAlB;AAEf;AACA;AACA;;AAEAI,MAAM,CAACC,OAAP,GAAiBC,aAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,aAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAI,EAAE,gBAAgBD,aAAlB,CAAJ,EAAsC,OAAO,IAAIA,aAAJ,CAAkBC,IAAlB,CAAP;AACtCL,EAAAA,QAAQ,CAACM,IAAT,CAAc,IAAd,EAAoBD,IAApB;AACA,OAAKE,OAAL,GAAe,EAAf;AACD;;AACDR,QAAQ,CAACK,aAAD,EAAgBJ,QAAhB,CAAR;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAI,aAAa,CAACI,SAAd,CAAwBC,KAAxB,GAAgC,UAAUC,CAAV,EAAaC,IAAb,EAAmB;AACjD,MAAI,KAAKJ,OAAL,CAAaK,MAAb,GAAsB,CAA1B,EAA6B;AAC3BC,IAAAA,MAAM,CAACP,IAAP,CAAY,IAAZ;AACD,GAFD,MAEO;AACLL,IAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,SAAKa,IAAL,CAAU,QAAV,EAAoBD,MAApB;AACD;;AAED,WAASA,MAAT,GAAmB;AACjBZ,IAAAA,KAAK,CAAC,UAAD,CAAL;;AACA,QAAIc,IAAI,GAAG,KAAKR,OAAL,CAAaS,KAAb,EAAX;;AACA,QAAIC,GAAG,GAAGF,IAAI,CAAC,CAAD,CAAd;AACA,QAAIG,EAAE,GAAGH,IAAI,CAAC,CAAD,CAAb;AACAG,IAAAA,EAAE;AAEF,QAAI,KAAKC,IAAT,EAAe,KAAKA,IAAL,CAAUF,GAAV,EAAf,KACKN,IAAI,CAAC,IAAD,EAAOM,GAAP,CAAJ,CARY,CAQK;AACvB;AACF,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAb,aAAa,CAACI,SAAd,CAAwBY,YAAxB,GAAuC,UAAUH,GAAV,EAAeC,EAAf,EAAmB;AACxD,OAAKX,OAAL,CAAaY,IAAb,CAAkB,CAAEF,GAAF,EAAOC,EAAP,CAAlB;;AACA,OAAKG,IAAL,CAAU,QAAV;AACD,CAHD","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar Readable = require('stream').Readable;\nvar debug = require('debug')('flv:decoder-stream');\n\n// node v0.8.x compat\nif (!Readable) Readable = require('readable-stream/readable');\n\n/**\n * Module exports.\n */\n\nmodule.exports = DecoderStream;\n\n/**\n * The `DecoderStream`.\n *\n * @param {Object} opts optional options object\n * @api public\n */\n\nfunction DecoderStream (opts) {\n  if (!(this instanceof DecoderStream)) return new DecoderStream(opts);\n  Readable.call(this, opts);\n  this._chunks = [];\n}\ninherits(DecoderStream, Readable);\n\n/**\n * Readable `_read()` callback function.\n *\n * @param {Number} n number of bytes requested (ignored)\n * @param {Function} done callback function (XXX: remove...)\n * @api private\n */\n\nDecoderStream.prototype._read = function (n, done) {\n  if (this._chunks.length > 0) {\n    output.call(this);\n  } else {\n    debug('waiting for a \"_chunk\" event');\n    this.once('_chunk', output);\n  }\n\n  function output () {\n    debug('output()');\n    var next = this._chunks.shift();\n    var buf = next[0];\n    var fn = next[1];\n    fn();\n\n    if (this.push) this.push(buf);\n    else done(null, buf); // XXX: old Readable stream API... remove at some point..\n  }\n};\n\n/**\n * Pushes a Buffer to be read from this `DecoderStream` instance. The `fn`\n * callback function only gets invoked once the ._read() function pulls the buffer\n * out to send to the user.\n *\n * @param {Buffer} buf Buffer instance\n * @param {Function} fn callback function\n * @api private\n */\n\nDecoderStream.prototype._pushAndWait = function (buf, fn) {\n  this._chunks.push([ buf, fn ]);\n  this.emit('_chunk');\n};\n"]},"metadata":{},"sourceType":"script"}