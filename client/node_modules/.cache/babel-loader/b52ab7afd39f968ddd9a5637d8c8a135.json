{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar assert = require('assert');\n\nvar constants = require('./constants');\n\nvar amf0Types = constants.amf0Types;\n/**\n * Module exports.\n */\n\nmodule.exports = read;\n/**\n * Reads an AMF object from the specified Buffer at the specified offset.\n *\n * @param {Buffer} buffer The Buffer instance to read from.\n * @param {Object|Number} info \"Options\" object, or the byte offset to begin reading from.\n * @return {Object|Array} The decoded AMF object.\n * @api public\n */\n\nfunction read(buffer, info) {\n  if ('number' == typeof info) info = {\n    offset: info\n  };\n  if (!info) info = {};\n  if (null == info.offset) info.offset = 0; // gets reset to 0 on each `read()` call\n\n  info.byteLength = 0; // read the \"type\" byte\n\n  var type = buffer.readUInt8(info.offset);\n  bytesUsed(info, 1);\n\n  switch (type) {\n    case amf0Types.kNumberType:\n      return readNumber(buffer, info);\n\n    case amf0Types.kBooleanType:\n      return readBoolean(buffer, info);\n\n    case amf0Types.kStringType:\n      return readString(buffer, info);\n\n    case amf0Types.kObjectType:\n      return readObject(buffer, info);\n\n    case amf0Types.kNullType:\n      return null;\n\n    case amf0Types.kUndefinedType:\n      return undefined;\n\n    case amf0Types.kECMAArrayType:\n      return readECMAArray(buffer, info);\n\n    case amf0Types.kObjectEndType:\n      return END_OBJECT;\n\n    case amf0Types.kStrictArrayType:\n      return readStrictArray(buffer, info);\n\n    case amf0Types.kDateType:\n      return readDate(buffer, info);\n\n    case amf0Types.kTypedObjectType:\n      return readTypedObject(buffer, info);\n\n    default:\n      throw new Error('\"type\" not yet implemented: ' + type);\n  }\n}\n\nfunction bytesUsed(info, n) {\n  info.offset += n;\n  info.byteLength += n;\n}\n\nfunction readNumber(buffer, info) {\n  var offset = info.offset;\n  bytesUsed(info, 8);\n  return buffer.readDoubleBE(offset);\n}\n\nfunction readBoolean(buffer, info) {\n  var offset = info.offset;\n  bytesUsed(info, 1);\n  return buffer.readUInt8(offset) !== 0;\n}\n\nfunction readString(buffer, info) {\n  var offset = info.offset;\n  var length = buffer.readUInt16BE(offset);\n  bytesUsed(info, 2);\n  offset = info.offset;\n  bytesUsed(info, length);\n  return buffer.toString('utf8', offset, offset + length);\n} // sentinel object that signifies the \"end\" of an ECMA Object/Array\n\n\nvar END_OBJECT = {\n  endObject: true\n};\n\nfunction readObject(buffer, info, object) {\n  var key, value;\n  if (!object) object = {};\n  var temp = {};\n\n  while (value !== END_OBJECT) {\n    temp.offset = info.offset;\n    temp.byteLength = 0;\n    key = readString(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n    temp.offset = info.offset;\n    value = read(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n    if (value !== END_OBJECT) object[key] = value;\n  }\n\n  assert.strictEqual(key, '');\n  assert.strictEqual(value, END_OBJECT);\n  return object;\n}\n\nfunction readECMAArray(buffer, info, array) {\n  if (!Array.isArray(array)) array = []; // ignored, and can't really be relied on since ECMA arrays can have numbered\n  // indices, and/or names keys which may or may not be counted here\n\n  var count = buffer.readUInt32BE(info.offset);\n  bytesUsed(info, 4); // at this point it's the same binary structure as a regular Object\n\n  readObject(buffer, info, array);\n  return array;\n}\n\nfunction readStrictArray(buffer, info, array) {\n  var value, temp;\n  if (!Array.isArray(array)) array = [];\n  var count = buffer.readUInt32BE(info.offset);\n  bytesUsed(info, 4);\n  temp = {};\n\n  for (var i = 0; i < count; i++) {\n    temp.offset = info.offset;\n    value = read(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n    array.push(value);\n  }\n\n  return array;\n}\n\nfunction readDate(buffer, info) {\n  // number of milliseconds elapsed since the epoch\n  // of midnight on 1st Jan 1970 in the UTC time zone\n  var millis = buffer.readDoubleBE(info.offset);\n  bytesUsed(info, 8); // reserved, not supported SHOULD be set to 0x0000 (not enforced)\n\n  var timezone = buffer.readInt16BE(info.offset);\n  bytesUsed(info, 2);\n  return new Date(millis);\n}\n\nfunction readTypedObject(buffer, info) {\n  // \"typed\" objects are just regular ECMA Objects with a String class name at the\n  // beginning\n  var name = readString(buffer, info);\n  var obj = readObject(buffer, info);\n  obj.__className__ = name;\n  return obj;\n}","map":{"version":3,"sources":["/Users/user/Desktop/React Apps/twitchClone/client/node_modules/amf/lib/read.js"],"names":["assert","require","constants","amf0Types","module","exports","read","buffer","info","offset","byteLength","type","readUInt8","bytesUsed","kNumberType","readNumber","kBooleanType","readBoolean","kStringType","readString","kObjectType","readObject","kNullType","kUndefinedType","undefined","kECMAArrayType","readECMAArray","kObjectEndType","END_OBJECT","kStrictArrayType","readStrictArray","kDateType","readDate","kTypedObjectType","readTypedObject","Error","n","readDoubleBE","length","readUInt16BE","toString","endObject","object","key","value","temp","strictEqual","array","Array","isArray","count","readUInt32BE","i","push","millis","timezone","readInt16BE","Date","name","obj","__className__"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar assert = require('assert');\nvar constants = require('./constants');\nvar amf0Types = constants.amf0Types;\n\n/**\n * Module exports.\n */\n\nmodule.exports = read;\n\n/**\n * Reads an AMF object from the specified Buffer at the specified offset.\n *\n * @param {Buffer} buffer The Buffer instance to read from.\n * @param {Object|Number} info \"Options\" object, or the byte offset to begin reading from.\n * @return {Object|Array} The decoded AMF object.\n * @api public\n */\n\nfunction read (buffer, info) {\n  if ('number' == typeof info) info = { offset: info };\n  if (!info) info = {};\n  if (null == info.offset) info.offset = 0;\n\n  // gets reset to 0 on each `read()` call\n  info.byteLength = 0;\n\n  // read the \"type\" byte\n  var type = buffer.readUInt8(info.offset);\n  bytesUsed(info, 1);\n\n  switch (type) {\n    case amf0Types.kNumberType:\n      return readNumber(buffer, info);\n    case amf0Types.kBooleanType:\n      return readBoolean(buffer, info);\n    case amf0Types.kStringType:\n      return readString(buffer, info);\n    case amf0Types.kObjectType:\n      return readObject(buffer, info);\n    case amf0Types.kNullType:\n      return null;\n    case amf0Types.kUndefinedType:\n      return undefined;\n    case amf0Types.kECMAArrayType:\n      return readECMAArray(buffer, info);\n    case amf0Types.kObjectEndType:\n      return END_OBJECT;\n    case amf0Types.kStrictArrayType:\n      return readStrictArray(buffer, info);\n    case amf0Types.kDateType:\n      return readDate(buffer, info);\n    case amf0Types.kTypedObjectType:\n      return readTypedObject(buffer, info);\n    default:\n      throw new Error('\"type\" not yet implemented: ' + type);\n  }\n}\n\nfunction bytesUsed (info, n) {\n  info.offset += n;\n  info.byteLength += n;\n}\n\nfunction readNumber (buffer, info) {\n  var offset = info.offset;\n  bytesUsed(info, 8);\n  return buffer.readDoubleBE(offset);\n}\n\nfunction readBoolean (buffer, info) {\n  var offset = info.offset;\n  bytesUsed(info, 1);\n  return buffer.readUInt8(offset) !== 0;\n}\n\nfunction readString (buffer, info) {\n  var offset = info.offset;\n\n  var length = buffer.readUInt16BE(offset);\n  bytesUsed(info, 2);\n\n  offset = info.offset;\n  bytesUsed(info, length);\n  return buffer.toString('utf8', offset, offset + length);\n}\n\n// sentinel object that signifies the \"end\" of an ECMA Object/Array\nvar END_OBJECT = { endObject: true };\n\nfunction readObject (buffer, info, object) {\n  var key, value;\n  if (!object) object = {};\n\n  var temp = {};\n  while (value !== END_OBJECT) {\n    temp.offset = info.offset;\n    temp.byteLength = 0;\n    key = readString(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n\n    temp.offset = info.offset;\n    value = read(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n\n    if (value !== END_OBJECT) object[key] = value;\n  }\n  assert.strictEqual(key, '');\n  assert.strictEqual(value, END_OBJECT);\n\n  return object;\n}\n\nfunction readECMAArray (buffer, info, array) {\n  if (!Array.isArray(array)) array = [];\n\n  // ignored, and can't really be relied on since ECMA arrays can have numbered\n  // indices, and/or names keys which may or may not be counted here\n  var count = buffer.readUInt32BE(info.offset);\n  bytesUsed(info, 4);\n\n  // at this point it's the same binary structure as a regular Object\n  readObject(buffer, info, array);\n\n  return array;\n}\n\nfunction readStrictArray (buffer, info, array) {\n  var value, temp;\n  if (!Array.isArray(array)) array = [];\n\n  var count = buffer.readUInt32BE(info.offset);\n  bytesUsed(info, 4);\n\n  temp = {};\n  for (var i = 0; i < count; i++) {\n    temp.offset = info.offset;\n    value = read(buffer, temp);\n    bytesUsed(info, temp.byteLength);\n    array.push(value);\n  }\n\n  return array;\n}\n\nfunction readDate (buffer, info) {\n  // number of milliseconds elapsed since the epoch\n  // of midnight on 1st Jan 1970 in the UTC time zone\n  var millis = buffer.readDoubleBE(info.offset);\n  bytesUsed(info, 8);\n\n  // reserved, not supported SHOULD be set to 0x0000 (not enforced)\n  var timezone = buffer.readInt16BE(info.offset);\n  bytesUsed(info, 2);\n\n  return new Date(millis);\n}\n\nfunction readTypedObject (buffer, info) {\n  // \"typed\" objects are just regular ECMA Objects with a String class name at the\n  // beginning\n  var name = readString(buffer, info);\n  var obj = readObject(buffer, info);\n  obj.__className__ = name;\n  return obj;\n}\n"]},"metadata":{},"sourceType":"script"}