{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar amf = require('amf');\n\nvar assert = require('assert');\n\nvar inherits = require('util').inherits;\n\nvar Writable = require('stream').Writable;\n\nvar Parser = require('stream-parser');\n\nvar debug = require('debug')('flv:decoder');\n\nvar DecoderStream = require('./decoder-stream'); // node v0.8.x compat\n\n\nif (!Writable) Writable = require('readable-stream/writable');\n/**\n * Module exports.\n */\n\nmodule.exports = Decoder;\n/**\n * The `Decoder` class is a `Writable` stream that expects an FLV file to be\n * written to it, and it will output the embedded audio and video stream in\n * \"audio\" and \"video\" events (respectively).\n *\n * A \"metadata\" event gets emitted every time a metadata chunk is encountered\n * inside the FLV file.\n *\n * Reference:\n *  - http://osflash.org/flv#flv_format\n *  - http://en.wikipedia.org/wiki/Flash_Video\n *\n * @param {Object} opts optional \"options\" object\n * @api public\n */\n\nfunction Decoder(opts) {\n  if (!(this instanceof Decoder)) return new Decoder(opts);\n  debug('creating new Decoder instance');\n  Writable.call(this, opts);\n  this.once('finish', this._onfinish);\n  this._streams = [];\n\n  this._bytes(3, this._onsignature);\n}\n\ninherits(Decoder, Writable);\n/**\n * Mixin `Parser`.\n */\n\nParser(Decoder.prototype);\n\nDecoder.prototype._onsignature = function (buf) {\n  var sig = buf.toString('ascii');\n  debug('onsignature(%j)', sig);\n\n  if ('FLV' != sig) {\n    return this.emit('error', new Error('invalid FLV signature: ' + JSON.stringify(sig)));\n  }\n\n  this.signature = sig;\n\n  this._bytes(1, this._onversion);\n};\n\nDecoder.prototype._onversion = function (buf) {\n  var ver = buf.readUInt8(0);\n  debug('onversion(%d)', ver);\n\n  if (1 !== ver) {\n    // currently 1 is the only version for known FLV files\n    return this.emit('error', new Error('expected flv version 1, got: ' + ver));\n  }\n\n  this.version = ver;\n\n  this._bytes(1, this._onflags);\n};\n\nDecoder.prototype._onflags = function (buf) {\n  var flags = buf.readUInt8(0);\n  debug('onflags(%d)', flags);\n  this.flags = flags;\n\n  this._bytes(4, this._onoffset);\n};\n\nDecoder.prototype._onoffset = function (buf) {\n  var offset = buf.readUInt32BE(0);\n  debug('onoffset(%d)', offset); // assert offset === 9\n\n  this.offset = offset;\n\n  this._bytes(4, this._onprevioustagsize);\n};\n\nDecoder.prototype._onprevioustagsize = function (buf) {\n  var size = buf.readUInt32BE(0);\n  debug('onprevioustagsize(%d)', size); // assert size === 0\n\n  this._bytes(1, this._ontagtype);\n};\n\nDecoder.prototype._ontagtype = function (buf) {\n  var type = buf.readUInt8(0);\n  debug('ontagtype(%d)', type);\n  this.currentTag = {\n    type: type\n  };\n\n  this._bytes(3, this._ontagbodylength);\n};\n\nDecoder.prototype._ontagbodylength = function (buf) {\n  var length = readUInt24BE(buf, 0);\n  debug('ontagbodylength(%d)', length);\n  this.currentTag.bodyLength = length; //this._bytes(3, this._ontagtimestamp);\n\n  this._bytes(4, this._ontagtimestamp);\n};\n\nDecoder.prototype._ontagtimestamp = function (buf) {\n  //var time = readUInt24BE(buf, 0);\n  var time = buf.readUInt32BE(0);\n  debug('ontagtimestamp(%d)', time);\n  this.currentTag.timestamp = time;\n\n  this._bytes(3, this._ontagstreamid);\n};\n\nDecoder.prototype._ontagstreamid = function (buf) {\n  var id = readUInt24BE(buf, 0);\n  debug('ontagstreamid(%d)', id);\n  this.currentTag.id = id;\n  var len = this.currentTag.bodyLength;\n\n  if (0 == len) {\n    // this shouldn't really happen, but _bytes() throws an assertion error\n    // if 0 is passed in, so just skip to the next step if 0 is reported\n    this._bytes(4, this._onprevioustagsize);\n  } else {\n    this._bytes(len, this._ontagbody);\n  }\n};\n\nDecoder.prototype._ontagbody = function (buf, fn) {\n  debug('ontagbody(%d bytes)', buf.length); // queue the next step before we start any async stuff\n\n  this._bytes(4, this._onprevioustagsize);\n\n  var stream;\n  this.currentTag.body = buf;\n\n  switch (this.currentTag.type) {\n    case 0x08:\n      // audio\n      debug('got \"audio\" tag');\n      stream = this._stream();\n      var meta = buf.readUInt8(0);\n      var soundType = (meta & 0x01) >> 0; // 0: mono, 1: stereo\n\n      var soundSize = (meta & 0x02) >> 1; // 0: 8-bit, 1: 16-bit\n\n      var soundRate = (meta & 0x0C) >> 2; // 0: 5.5 kHz (or speex 16kHz), 1: 11 kHz, 2: 22 kHz, 3: 44 kHz\n\n      var soundFormat = (meta & 0xf0) >> 4; // 0: Uncompressed, 1: ADPCM, 2: MP3, 5: Nellymoser 8kHz mono, 6: Nellymoser, 10: AAC, 11: Speex, more\n\n      this.currentTag.soundType = soundType;\n      this.currentTag.soundSize = soundSize;\n      this.currentTag.soundRate = soundRate;\n      this.currentTag.soundFormat = soundFormat; //console.error(this.currentTag);\n\n      if (soundFormat == 10) {\n        // AAC audio needs special handling\n        var aacType = buf.readUInt8(1);\n        var bits;\n\n        if (0 == aacType) {\n          // AAC sequence header\n          // This is an AudioSpecificConfig as specified in ISO 14496-3\n          var header = buf.slice(2);\n          assert(header.length >= 2);\n          bits = (header[0] & 0xff) * 256 + (header[1] & 0xff) << 16;\n          stream.aacProfile = readBits(bits, 5) - 1;\n          bits <<= 5;\n          stream.sampleRateIndex = readBits(bits, 4);\n          bits <<= 4;\n          stream.channelConfig = readBits(bits, 4);\n          fn();\n        } else {\n          // AAC raw (no ADTS header)\n          var audioData = buf.slice(2);\n          var dataSize = audioData.length; // need to construct an ADTS header manually...\n          // see http://wiki.multimedia.cx/index.php?title=ADTS for format spec\n          // https://github.com/gangverk/flvdemux/blob/master/src/com/gangverk/FLVDemuxingInputStream.java\n          // http://codeartisan.tumblr.com/post/11943952404/playing-flv-wrapped-aac-streams-from-android\n\n          var adts = new Buffer(7);\n          bits = 0;\n          bits = writeBits(bits, 12, 0xFFF);\n          bits = writeBits(bits, 3, 0);\n          bits = writeBits(bits, 1, 1);\n          adts[0] = bits >> 8;\n          adts[1] = bits;\n          bits = 0;\n          bits = writeBits(bits, 2, stream.aacProfile);\n          bits = writeBits(bits, 4, stream.sampleRateIndex);\n          bits = writeBits(bits, 1, 0);\n          bits = writeBits(bits, 3, stream.channelConfig);\n          bits = writeBits(bits, 4, 0);\n          bits = writeBits(bits, 2, dataSize + 7 & 0x1800);\n          adts[2] = bits >> 8;\n          adts[3] = bits;\n          bits = 0;\n          bits = writeBits(bits, 11, dataSize + 7 & 0x7FF);\n          bits = writeBits(bits, 11, 0x7FF);\n          bits = writeBits(bits, 2, 0);\n          adts[4] = bits >> 16;\n          adts[5] = bits >> 8;\n          adts[6] = bits; // first write the ADTS header\n\n          stream._pushAndWait(adts, function () {\n            // then write the raw AAC data\n            stream._pushAndWait(audioData, fn);\n          }); // alternate way using `Buffer.concat()` instead - benchmark someday\n\n          /*var b = Buffer.concat([ adts, audioData ]);\n          stream._pushAndWait(b, fn);*/\n\n        }\n      } else {\n        // the raw audio data Buffer (MP3 data or whatever...)\n        this.currentTag.audioData = buf.slice(1);\n\n        stream._pushAndWait(this.currentTag.audioData, fn);\n      }\n\n      break;\n\n    case 0x09:\n      // video\n      debug('got \"video\" tag'); // TODO: implement\n\n      stream = this._stream();\n      fn();\n      break;\n\n    case 0x12:\n      // metadata\n      debug('got \"metadata\" tag'); // metadata is in AMF format, 2 packets\n\n      var position = {\n        offset: 0\n      }; // first packet is an AMF \"string\", the event name\n\n      var name = amf.read(buf, position);\n      this.currentTag.name = name; // second packet is the \"data\" payload, which is an AMF \"array\"\n\n      var data = amf.read(buf, position);\n      this.currentTag.data = data;\n      this.emit('metadata', name, data, this.currentTag);\n      fn();\n      break;\n\n    default:\n      this.emit('error', new Error('unknown tag type: ' + this.currentTag.type));\n      return;\n  }\n};\n/**\n * Returns a `DecoderStream` instance that corresponds with the current \"tag\"\n * being parsed.\n *\n * @return {DecoderStream} The DecoderStream instance for the current \"tag\"\n * @api private\n */\n\n\nDecoder.prototype._stream = function () {\n  var name = this.currentTag.type + '-' + this.currentTag.id;\n  var stream = this[name];\n  var type = this.currentTag.type;\n\n  if (!stream) {\n    debug('creating DecoderStream instance for %j', name);\n    stream = this[name] = new DecoderStream(); // also add them to an array so that we can iterate the streams in \"finish\"\n\n    this._streams.push(stream); // emit an \"audio\" or \"video\" event\n\n\n    if (0x08 == type) {\n      // audio\n      name = 'audio';\n    } else if (0x09 == type) {\n      // video\n      name = 'video';\n    } else {\n      throw new Error('unsupported \"stream\" type: ' + type);\n    }\n\n    this.emit(name, stream);\n  }\n\n  return stream;\n};\n/**\n * Called for the Decoder's \"finish\" event. Pushes the `null` packet to the audio\n * and/or video stream in the FLV file, so that they emit \"end\".\n *\n * @api private\n */\n\n\nDecoder.prototype._onfinish = function () {\n  debug('\"finish\" event');\n\n  this._streams.forEach(function (stream) {\n    stream._pushAndWait(null, function () {\n      debug('`null` packet flushed');\n    });\n  });\n\n  this._streams.splice(0); // empty\n\n};\n/**\n * Node.js Buffer class doesn't have readUInt24...\n */\n\n\nfunction readUInt24BE(buffer, offset) {\n  var val = 0;\n  val |= buffer[offset + 2];\n  val |= buffer[offset + 1] << 8;\n  val |= buffer[offset + 0] << 16;\n  return val;\n}\n\nfunction readBits(x, length) {\n  return x >> 32 - length;\n}\n\nfunction writeBits(x, length, value) {\n  var mask = 0xffffffff >> 32 - length;\n  x = x << length | value & mask;\n  return x;\n}","map":{"version":3,"sources":["/Users/user/Desktop/React Apps/twitchClone/client/node_modules/flv/lib/decoder.js"],"names":["amf","require","assert","inherits","Writable","Parser","debug","DecoderStream","module","exports","Decoder","opts","call","once","_onfinish","_streams","_bytes","_onsignature","prototype","buf","sig","toString","emit","Error","JSON","stringify","signature","_onversion","ver","readUInt8","version","_onflags","flags","_onoffset","offset","readUInt32BE","_onprevioustagsize","size","_ontagtype","type","currentTag","_ontagbodylength","length","readUInt24BE","bodyLength","_ontagtimestamp","time","timestamp","_ontagstreamid","id","len","_ontagbody","fn","stream","body","_stream","meta","soundType","soundSize","soundRate","soundFormat","aacType","bits","header","slice","aacProfile","readBits","sampleRateIndex","channelConfig","audioData","dataSize","adts","Buffer","writeBits","_pushAndWait","position","name","read","data","push","forEach","splice","buffer","val","x","value","mask"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar amf = require('amf');\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar Writable = require('stream').Writable;\nvar Parser = require('stream-parser');\nvar debug = require('debug')('flv:decoder');\nvar DecoderStream = require('./decoder-stream');\n\n// node v0.8.x compat\nif (!Writable) Writable = require('readable-stream/writable');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Decoder;\n\n/**\n * The `Decoder` class is a `Writable` stream that expects an FLV file to be\n * written to it, and it will output the embedded audio and video stream in\n * \"audio\" and \"video\" events (respectively).\n *\n * A \"metadata\" event gets emitted every time a metadata chunk is encountered\n * inside the FLV file.\n *\n * Reference:\n *  - http://osflash.org/flv#flv_format\n *  - http://en.wikipedia.org/wiki/Flash_Video\n *\n * @param {Object} opts optional \"options\" object\n * @api public\n */\n\nfunction Decoder (opts) {\n  if (!(this instanceof Decoder)) return new Decoder(opts);\n  debug('creating new Decoder instance');\n  Writable.call(this, opts);\n\n  this.once('finish', this._onfinish);\n  this._streams = [];\n  this._bytes(3, this._onsignature);\n}\ninherits(Decoder, Writable);\n\n/**\n * Mixin `Parser`.\n */\n\nParser(Decoder.prototype);\n\nDecoder.prototype._onsignature = function (buf) {\n  var sig = buf.toString('ascii');\n  debug('onsignature(%j)', sig);\n  if ('FLV' != sig) {\n    return this.emit('error', new Error('invalid FLV signature: ' + JSON.stringify(sig)));\n  }\n  this.signature = sig;\n  this._bytes(1, this._onversion);\n};\n\nDecoder.prototype._onversion = function (buf) {\n  var ver = buf.readUInt8(0);\n  debug('onversion(%d)', ver);\n  if (1 !== ver) {\n    // currently 1 is the only version for known FLV files\n    return this.emit('error', new Error('expected flv version 1, got: ' + ver));\n  }\n  this.version = ver;\n  this._bytes(1, this._onflags);\n};\n\nDecoder.prototype._onflags = function (buf) {\n  var flags = buf.readUInt8(0);\n  debug('onflags(%d)', flags);\n  this.flags = flags;\n  this._bytes(4, this._onoffset);\n};\n\nDecoder.prototype._onoffset = function (buf) {\n  var offset = buf.readUInt32BE(0);\n  debug('onoffset(%d)', offset);\n  // assert offset === 9\n  this.offset = offset;\n  this._bytes(4, this._onprevioustagsize);\n};\n\nDecoder.prototype._onprevioustagsize = function (buf) {\n  var size = buf.readUInt32BE(0);\n  debug('onprevioustagsize(%d)', size);\n  // assert size === 0\n  this._bytes(1, this._ontagtype);\n};\n\nDecoder.prototype._ontagtype = function (buf) {\n  var type = buf.readUInt8(0);\n  debug('ontagtype(%d)', type);\n  this.currentTag = { type: type };\n  this._bytes(3, this._ontagbodylength);\n};\n\nDecoder.prototype._ontagbodylength = function (buf) {\n  var length = readUInt24BE(buf, 0);\n  debug('ontagbodylength(%d)', length);\n  this.currentTag.bodyLength = length;\n  //this._bytes(3, this._ontagtimestamp);\n  this._bytes(4, this._ontagtimestamp);\n};\n\nDecoder.prototype._ontagtimestamp = function (buf) {\n  //var time = readUInt24BE(buf, 0);\n  var time = buf.readUInt32BE(0);\n  debug('ontagtimestamp(%d)', time);\n  this.currentTag.timestamp = time;\n  this._bytes(3, this._ontagstreamid);\n};\n\nDecoder.prototype._ontagstreamid = function (buf) {\n  var id = readUInt24BE(buf, 0);\n  debug('ontagstreamid(%d)', id);\n  this.currentTag.id = id;\n  var len = this.currentTag.bodyLength;\n  if (0 == len) {\n    // this shouldn't really happen, but _bytes() throws an assertion error\n    // if 0 is passed in, so just skip to the next step if 0 is reported\n    this._bytes(4, this._onprevioustagsize);\n  } else {\n    this._bytes(len, this._ontagbody);\n  }\n};\n\nDecoder.prototype._ontagbody = function (buf, fn) {\n  debug('ontagbody(%d bytes)', buf.length);\n\n  // queue the next step before we start any async stuff\n  this._bytes(4, this._onprevioustagsize);\n\n  var stream;\n  this.currentTag.body = buf;\n  switch (this.currentTag.type) {\n    case 0x08: // audio\n      debug('got \"audio\" tag');\n      stream = this._stream();\n      var meta = buf.readUInt8(0);\n      var soundType = (meta & 0x01) >> 0; // 0: mono, 1: stereo\n      var soundSize = (meta & 0x02) >> 1; // 0: 8-bit, 1: 16-bit\n      var soundRate = (meta & 0x0C) >> 2; // 0: 5.5 kHz (or speex 16kHz), 1: 11 kHz, 2: 22 kHz, 3: 44 kHz\n      var soundFormat = (meta & 0xf0) >> 4; // 0: Uncompressed, 1: ADPCM, 2: MP3, 5: Nellymoser 8kHz mono, 6: Nellymoser, 10: AAC, 11: Speex, more\n      this.currentTag.soundType = soundType;\n      this.currentTag.soundSize = soundSize;\n      this.currentTag.soundRate = soundRate;\n      this.currentTag.soundFormat = soundFormat;\n      //console.error(this.currentTag);\n\n      if (soundFormat == 10) {\n        // AAC audio needs special handling\n        var aacType = buf.readUInt8(1);\n        var bits;\n        if (0 == aacType) {\n          // AAC sequence header\n          // This is an AudioSpecificConfig as specified in ISO 14496-3\n          var header = buf.slice(2);\n          assert(header.length >= 2);\n\n          bits = ((header[0] & 0xff) * 256 + (header[1] & 0xff)) << 16;\n          stream.aacProfile = readBits(bits, 5) - 1;\n          bits <<= 5;\n          stream.sampleRateIndex = readBits(bits, 4);\n          bits <<= 4;\n          stream.channelConfig = readBits(bits, 4);\n\n          fn();\n        } else {\n          // AAC raw (no ADTS header)\n          var audioData = buf.slice(2);\n          var dataSize = audioData.length;\n\n          // need to construct an ADTS header manually...\n          // see http://wiki.multimedia.cx/index.php?title=ADTS for format spec\n          // https://github.com/gangverk/flvdemux/blob/master/src/com/gangverk/FLVDemuxingInputStream.java\n          // http://codeartisan.tumblr.com/post/11943952404/playing-flv-wrapped-aac-streams-from-android\n          var adts = new Buffer(7);\n          bits = 0;\n          bits = writeBits(bits, 12, 0xFFF);\n          bits = writeBits(bits, 3, 0);\n          bits = writeBits(bits, 1, 1);\n          adts[0] = (bits >> 8);\n          adts[1] = (bits);\n\n          bits = 0;\n          bits = writeBits(bits, 2, stream.aacProfile);\n          bits = writeBits(bits, 4, stream.sampleRateIndex);\n          bits = writeBits(bits, 1, 0);\n          bits = writeBits(bits, 3, stream.channelConfig);\n          bits = writeBits(bits, 4, 0);\n          bits = writeBits(bits, 2, (dataSize + 7) & 0x1800);\n\n          adts[2] = (bits >> 8);\n          adts[3] = (bits);\n\n          bits = 0;\n          bits = writeBits(bits, 11, (dataSize + 7) & 0x7FF);\n          bits = writeBits(bits, 11, 0x7FF);\n          bits = writeBits(bits, 2, 0);\n          adts[4] = (bits >> 16);\n          adts[5] = (bits >> 8);\n          adts[6] = (bits);\n\n          // first write the ADTS header\n          stream._pushAndWait(adts, function () {\n            // then write the raw AAC data\n            stream._pushAndWait(audioData, fn);\n          });\n\n          // alternate way using `Buffer.concat()` instead - benchmark someday\n          /*var b = Buffer.concat([ adts, audioData ]);\n          stream._pushAndWait(b, fn);*/\n        }\n      } else {\n        // the raw audio data Buffer (MP3 data or whatever...)\n        this.currentTag.audioData = buf.slice(1);\n        stream._pushAndWait(this.currentTag.audioData, fn);\n      }\n      break;\n    case 0x09: // video\n      debug('got \"video\" tag');\n      // TODO: implement\n      stream = this._stream();\n      fn();\n      break;\n    case 0x12: // metadata\n      debug('got \"metadata\" tag');\n      // metadata is in AMF format, 2 packets\n      var position = { offset: 0 };\n\n      // first packet is an AMF \"string\", the event name\n      var name = amf.read(buf, position);\n      this.currentTag.name = name;\n\n      // second packet is the \"data\" payload, which is an AMF \"array\"\n      var data = amf.read(buf, position);\n      this.currentTag.data = data;\n\n      this.emit('metadata', name, data, this.currentTag);\n      fn();\n      break;\n    default:\n      this.emit('error', new Error('unknown tag type: ' + this.currentTag.type));\n      return;\n  }\n};\n\n/**\n * Returns a `DecoderStream` instance that corresponds with the current \"tag\"\n * being parsed.\n *\n * @return {DecoderStream} The DecoderStream instance for the current \"tag\"\n * @api private\n */\n\nDecoder.prototype._stream = function () {\n  var name = this.currentTag.type + '-' + this.currentTag.id;\n  var stream = this[name];\n  var type = this.currentTag.type;\n  if (!stream) {\n    debug('creating DecoderStream instance for %j', name);\n    stream = this[name] = new DecoderStream();\n\n    // also add them to an array so that we can iterate the streams in \"finish\"\n    this._streams.push(stream);\n\n    // emit an \"audio\" or \"video\" event\n    if (0x08 == type) { // audio\n      name = 'audio';\n    } else if (0x09 == type) { // video\n      name = 'video';\n    } else {\n      throw new Error('unsupported \"stream\" type: ' + type);\n    }\n    this.emit(name, stream);\n  }\n  return stream;\n};\n\n/**\n * Called for the Decoder's \"finish\" event. Pushes the `null` packet to the audio\n * and/or video stream in the FLV file, so that they emit \"end\".\n *\n * @api private\n */\n\nDecoder.prototype._onfinish = function () {\n  debug('\"finish\" event');\n  this._streams.forEach(function (stream) {\n    stream._pushAndWait(null, function () {\n      debug('`null` packet flushed');\n    });\n  });\n  this._streams.splice(0); // empty\n};\n\n/**\n * Node.js Buffer class doesn't have readUInt24...\n */\n\nfunction readUInt24BE (buffer, offset) {\n  var val = 0;\n  val |= buffer[offset + 2];\n  val |= buffer[offset + 1] << 8;\n  val |= buffer[offset + 0] << 16;\n  return val;\n}\n\nfunction readBits (x, length) {\n  return (x >> (32 - length));\n}\n\nfunction writeBits (x, length, value) {\n  var mask = 0xffffffff >> (32 - length);\n  x = (x << length) | (value & mask);\n  return x;\n}\n"]},"metadata":{},"sourceType":"script"}